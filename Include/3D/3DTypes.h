#ifndef THREEDTYPES_H#define THREEDTYPES_H#pragma onceconst float CULL_NEAR = 1.0;const float CULL_FAR = 50.0;#include ":3D:Vector3f.h"const float ONE_RADIAN = (3.141592654 / 180.0);typedef struct bresenhampoints_t {	Point left;	Point right;		bresenhampoints_t() {		left.h = 640;		left.v = -1;		right.h = -1;		right.v = -1;	}		void Put(Point p){		if(p.h < left.h) left = p;		if(p.h > right.h) right = p;				//Assert_(left.v == right.v);	}} BresenhamPoints;typedef enum winding_t {	WINDING_CW,	WINDING_CCW} Winding;typedef struct triangle_t {	public:	Point3D vertices[3];		triangle_t(Point3D p1, Point3D p2, Point3D p3){		vertices[0].x = p1.x;		vertices[0].y = p1.y;		vertices[0].z = p1.z;				vertices[1].x = p2.x;		vertices[1].y = p2.y;		vertices[1].z = p2.z;				vertices[2].x = p3.x;		vertices[2].y = p3.y;		vertices[2].z = p3.z;	}		Vector3f Centroid();	Vector3f CalculateSurfaceNormal();	Winding GetWinding();	} Triangle;typedef struct matrix44_t {	float data[4][4];		//Initialize a new matrix to the zero matrix.	matrix44_t() {		data[0][0] = 0;		data[0][1] = 0;		data[0][2] = 0;		data[0][3] = 0;				data[1][0] = 0;		data[1][1] = 0;		data[1][2] = 0;		data[1][3] = 0;				data[2][0] = 0;		data[2][1] = 0;		data[2][2] = 0;		data[2][3] = 0;				data[3][0] = 0;		data[3][1] = 0;		data[3][2] = 0;		data[3][3] = 0;	}		static matrix44_t FromPoint3D(Point3D p){		matrix44_t m = Identity();				m.data[0][3] = p.x;		m.data[1][3] = p.y;		m.data[2][3] = p.z;				return m;	}		static matrix44_t Identity() {		matrix44_t m;				for(int i=0;i<4;i++){			m.data[i][i] = 1;		}				return m;	}		matrix44_t operator* (matrix44_t m){		matrix44_t result;			for(int rightRow = 0; rightRow < 4; rightRow++){			for(int row=0; row<4; row++){				for(int col=0; col<4; col++){					result.data[row][rightRow] += data[row][col] * m.data[col][rightRow];				}			}		}				return result;	}		Vector3f MatrixVectorProduct(Vector3f v);	} Matrix44;typedef struct orientation_t {	Vector3f translation;	Vector3f rotation;	Vector3f scale;		orientation_t() {		translation = Vector3f(0,0,0);		rotation 	= Vector3f(0,0,0);		scale		= Vector3f(1,1,1);	}		Vector3f GetTranslation() { return translation; }	Vector3f GetRotation() { return rotation; }	Vector3f GetScale()	{ return scale; }		Matrix44 GetTransformationMatrix();			Matrix44 GetTranslationMatrix();	Matrix44 GetScaleMatrix();	Matrix44 GetXRotationMatrix();	Matrix44 GetYRotationMatrix();	Matrix44 GetZRotationMatrix();	Matrix44 GetPerspectiveMatrix();	} Orientation;#endif