/* A Vector3 containing floats. */#ifndef VECTOR3F_H#define VECTOR3F_H#pragma once#include <cmath>typedef struct vector3f_t {	float x;	float y;	float z;		//Constructors	vector3f_t() { x = 0; y = 0; z = 0; }	vector3f_t(int _x, int _y, int _z) { x = _x; y = _y; z = _z; }	vector3f_t(float _x, float _y, float _z) { x = _x; y = _y; z = _z; }	vector3f_t(const vector3f_t &original) { x = original.x; y = original.y; z = original.z; }		//Operators	vector3f_t operator+ (const vector3f_t &operand) {		return vector3f_t(this->x + operand.x, this->y + operand.y, this->z + operand.z);	}	vector3f_t operator- (const vector3f_t &operand) {		return vector3f_t(this->x - operand.x, this->y - operand.y, this->z - operand.z);	}		vector3f_t operator* (const float scale) { return vector3f_t(x*scale, y*scale, z*scale); }	vector3f_t operator/ (const float scale) { return vector3f_t(x/scale, y/scale, z/scale); }		float Length() { return std::sqrt(x*x + y*y + z*z); }	vector3f_t Negate() { return vector3f_t(-x, -y, -z); }	vector3f_t Normalize() {		float magnitude = Length();				if(magnitude != 0) {			return vector3f_t(x/magnitude, y/magnitude, z/magnitude);		} else {			return vector3f_t();		}	}		static float DotProduct(vector3f_t a, vector3f_t b){		return (a.x*b.x) + (a.y*b.y) + (a.z*b.z);	}		static vector3f_t CrossProduct(const vector3f_t a, const vector3f_t b) {		return vector3f_t((a.y * b.z) - (a.z * b.y),						  (a.z * b.x) - (a.x * b.z),						  (a.x * b.y) - (a.y * b.x));	}		static float Distance(vector3f_t v1, vector3f_t v2) {		return std::sqrt(std::pow(v1.x - v2.x, 2) + std::pow(v1.y - v2.y, 2) + std::pow(v1.z - v2.z, 2));	}		static vector3f_t Lerp(vector3f_t v1, vector3f_t v2, float t){		return (v1 + (v2-v1)*t);	}	} Vector3f;typedef vector3f_t Point3D;#endif