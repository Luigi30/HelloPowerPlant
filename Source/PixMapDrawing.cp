#include "PixMapDrawing.h"#include <cmath>template <typename T>void Swap(T &a, T &b) {	T temp = b;	b = a;	a = temp;}void PixMapDrawing::Bresenham(Ptr pixels, std::map<int, BresenhamPoints> *edges, Point p1, Point p2, UInt8 color, TriangleEdge edgeType) {	int rowOffset = (GetPixMapPtr()->rowBytes & 0x3FFF);		bool steep = std::fabs(p2.v - p1.v) > std::fabs(p2.h - p1.h);	if(steep) {		Swap(p1.h, p1.v);		Swap(p2.h, p2.v);	}		if(p1.h > p2.h){		Swap(p1, p2);	}		float dX = p2.h - p1.h;	float dY = std::fabs(p2.v - p1.v);		int error = dX / 2.0f;	int yStep = (p1.v < p2.v) ? 1 : -1;	int y = p1.v;		std::map<int, BresenhamPoints>::iterator it;		for(int x=p1.h; x <= p2.h; x++){		BresenhamPoints b;		if(x >= 0 && x < 640 && y >= 0 && y < 480){		 			if(steep){				Point p = { x, y };				if(edgeType != EDGE_NONE) {					it = edges->find(x);					if(it == edges->end()) {						b.Put(p);						edges->insert(std::pair<int, BresenhamPoints>(x, b));					} else {						it->second.Put(p);					}								}				pixels[y + (rowOffset*x)] = color;			} else {				Point p = { y, x };				if(edgeType != EDGE_NONE) {					it = edges->find(y);					if(it == edges->end()) {						b.Put(p);						edges->insert(std::pair<int, BresenhamPoints>(y, b));					} else {						it->second.Put(p);					}				}				pixels[x + (rowOffset*y)] = color;			}		}					error -= dY;		if(error < 0) {			y += yStep;			error += dX;		}	}}/* Fills a flat-bottom triangle. */void PixMapDrawing::BresenhamBottomFill(Triangle tri, UInt8 shade){	Ptr pixels = ::GetPixBaseAddr(GetPixMapHandle());	int rowOffset = (GetPixMapPtr()->rowBytes & 0x3FFF);	Point l1p1, l1p2;	Point l2p1, l2p2;	l1p1.h = tri.vertices[0].x;	l1p1.v = tri.vertices[0].y;	l1p2.h = tri.vertices[1].x;	l1p2.v = tri.vertices[1].y; 		l2p1.h = tri.vertices[0].x;	l2p1.v = tri.vertices[0].y;	l2p2.h = tri.vertices[2].x;	l2p2.v = tri.vertices[2].y;		std::map<int, BresenhamPoints> edges;		Bresenham(pixels, &edges, l1p1, l1p2, 255, EDGE_HORIZONTAL);	Bresenham(pixels, &edges, l2p1, l2p2, 255, EDGE_HORIZONTAL);		std::map<int, BresenhamPoints>::iterator it;	for(int i=0;i<480;i++){		it = edges.find(i);			if(it != edges.end()) {			Bresenham(pixels, NULL, it->second.left, it->second.right, shade, EDGE_NONE);		}	}}/* Fills a flat-top triangle. */void PixMapDrawing::BresenhamTopFill(Triangle tri, UInt8 shade){	Ptr pixels = ::GetPixBaseAddr(GetPixMapHandle());	int rowOffset = (GetPixMapPtr()->rowBytes & 0x3FFF);	Point l1p1, l1p2;	Point l2p1, l2p2;	l1p1.h = tri.vertices[2].x;	l1p1.v = tri.vertices[2].y;	l1p2.h = tri.vertices[0].x;	l1p2.v = tri.vertices[0].y; 		l2p1.h = tri.vertices[2].x;	l2p1.v = tri.vertices[2].y;	l2p2.h = tri.vertices[1].x;	l2p2.v = tri.vertices[1].y;		std::map<int, BresenhamPoints> edges;		Bresenham(pixels, &edges, l1p1, l1p2, 255, EDGE_VERTICAL);	Bresenham(pixels, &edges, l2p1, l2p2, 255, EDGE_VERTICAL);		std::map<int, BresenhamPoints>::iterator it;	for(int i=0;i<480;i++){		it = edges.find(i);			if(it != edges.end()) {			Bresenham(pixels, NULL, it->second.left, it->second.right, shade, EDGE_NONE);		}	}}Point PixMapDrawing::BresenhamUntilYChange(Ptr pixels, std::map<int, BresenhamPoints> *edges, Point p1, Point p2, UInt8 color){	int rowOffset = (GetPixMapPtr()->rowBytes & 0x3FFF);		bool steep = std::fabs(p2.v - p1.v) > std::fabs(p2.h - p1.h);	if(steep) {		Swap(p1.h, p1.v);		Swap(p2.h, p2.v);	}		if(p1.h > p2.h){		Swap(p1, p2);	}		float dX = p2.h - p1.h;	float dY = std::fabs(p2.v - p1.v);		int error = dX / 2.0f;	int yStep = (p1.v < p2.v) ? 1 : -1;	short y = p1.v;	Point p;	p.h = p1.h;	p.v = p1.v;		bool yStepOccurred = false;	for(short x=p1.h; x <= p2.h; x++){		if(x >= 0 && x < 640 && y >= 0 && y < 480){		 			if(steep){				pixels[y + (rowOffset*x)] = color;				p.h = y;				p.v = x;			} else {				pixels[x + (rowOffset*y)] = color;				p.h = x;				p.v = y;			}		}					error -= dY;		if(error < 0) {			yStepOccurred = true;			y += yStep;			if(steep){				p.h = y;				p.v = x;			} else {				p.h = x;				p.v = y;			}			return p;			error += dX;		}	}		if(yStepOccurred == false){		p.v++;	}	return p;}void PixMapDrawing::DrawLine(Point p1, Point p2, UInt8 colorIndex) {	Assert_(GetPixMapPtr()->pixelType == 0); //indexed	UInt8 pixelDepth = GetPixMapPtr()->pixelSize;		//High 2 bits are flags so ignore them.	int rowOffset = (GetPixMapPtr()->rowBytes & 0x3FFF);	//Retrieve the base address of the pixel buffer.	Ptr pixels = ::GetPixBaseAddr(GetPixMapHandle());		//Our drawing code requires a pixel depth of 8 on our PixMap.	Assert_(pixelDepth == 8);		//Bresenham's algorithm.	//Bresenham(pixels, NULL, p1, p2, colorIndex);}