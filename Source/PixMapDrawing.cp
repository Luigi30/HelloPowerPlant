#include "PixMapDrawing.h"#include <cmath>#include <cstdio>template <typename T>void Swap(T &a, T &b) {	T temp = b;	b = a;	a = temp;}void PixMapDrawing::Bresenham3D(Ptr pixels, std::map<int, BresenhamPoints3D> *edges, Point3D p1, Point3D p2, UInt8 color, TriangleEdge edgeType) {	Assert_(zBuffer != NULL);		int rowOffset = (GetPixMapPtr()->rowBytes & 0x3FFF);		bool steep = std::fabs(p2.y - p1.y) > std::fabs(p2.x - p1.x);	if(steep) {		Swap(p1.x, p1.y);		Swap(p2.x, p2.y);	}		if(p1.x > p2.x){		Swap(p1, p2);	}		float dX = p2.x - p1.x;	float dY = std::fabs(p2.y - p1.y);		int error = dX / 2.0f;	int yStep = (p1.y < p2.y) ? 1 : -1;	int y = p1.y;		Point3D p1_noZ((float)p1.x, (float)p1.y, 0.0f);	Point3D p2_noZ((float)p2.x, (float)p2.y, 0.0f);	float distanceP1toP2 = Vector3f::Distance(p1_noZ, p2_noZ);	float remainingDistance;		std::map<int, BresenhamPoints3D>::iterator it;		for(int x=p1.x; x <= p2.x; x++){		BresenhamPoints3D b;		if(x >= 0 && x < 512 && y >= 0 && y < 384){		 			if(steep){				remainingDistance = Vector3f::Distance(Point3D(x, y, 0), p2_noZ);				Point3D p((float)y, (float)x, Vector3f::Lerp(p1, p2, (distanceP1toP2 - remainingDistance) / distanceP1toP2).z);								if(edgeType != EDGE_NONE) {					it = edges->find(x);					if(it == edges->end()) {						b.Put(p);						edges->insert(std::pair<int, BresenhamPoints3D>(x, b));					} else {						it->second.Put(p);					}								}				if(zBuffer[y + (rowOffset*x)] > p.z) { //lower p.z = closer					pixels[y + (rowOffset*x)] = color;					zBuffer[y + (rowOffset*x)] = p.z;				}			} else {				remainingDistance = Vector3f::Distance(Point3D(x, y, 0), p2_noZ);				Point3D p((float)x, (float)y, Vector3f::Lerp(p1, p2, (distanceP1toP2 - remainingDistance) / distanceP1toP2).z);								if(edgeType != EDGE_NONE) {					it = edges->find(y);					if(it == edges->end()) {						b.Put(p);						edges->insert(std::pair<int, BresenhamPoints3D>(y, b));					} else {						it->second.Put(p);					}				}				if(zBuffer[x + (rowOffset*y)] > p.z) { //lower p.z = closer					pixels[x + (rowOffset*y)] = color;					zBuffer[x + (rowOffset*y)] = p.z;				}			}		}					error -= dY;		if(error < 0) {			y += yStep;			error += dX;		}	}		return;}/* Fills a flat-bottom triangle. */void PixMapDrawing::BresenhamBottomFill(Triangle tri, UInt8 shade){	Ptr pixels = ::GetPixBaseAddr(GetPixMapHandle());	int rowOffset = (GetPixMapPtr()->rowBytes & 0x3FFF);	std::map<int, BresenhamPoints3D> edges;	Bresenham3D(pixels, &edges, tri.vertices[0], tri.vertices[1], shade, EDGE_HORIZONTAL);	Bresenham3D(pixels, &edges, tri.vertices[0], tri.vertices[2], shade, EDGE_HORIZONTAL);		for(std::map<int, BresenhamPoints3D>::iterator it = edges.begin(); it != edges.end(); it++){		Bresenham3D(pixels, NULL, it->second.left, it->second.right, shade, EDGE_NONE);	}}/* Fills a flat-top triangle. */void PixMapDrawing::BresenhamTopFill(Triangle tri, UInt8 shade){	Ptr pixels = ::GetPixBaseAddr(GetPixMapHandle());	int rowOffset = (GetPixMapPtr()->rowBytes & 0x3FFF);		std::map<int, BresenhamPoints3D> edges;	Bresenham3D(pixels, &edges, tri.vertices[2], tri.vertices[0], shade, EDGE_VERTICAL);	Bresenham3D(pixels, &edges, tri.vertices[2], tri.vertices[1], shade, EDGE_VERTICAL);		for(std::map<int, BresenhamPoints3D>::iterator it = edges.begin(); it != edges.end(); it++){		Bresenham3D(pixels, NULL, it->second.left, it->second.right, shade, EDGE_NONE);	}}asm void PixMapDrawing::ResetZBuffer() {	//std::memset(zBuffer, 0, zBufferLength);	//32-bit word	//r3 = *this	lis		r7,0x7f7fffff@h	ori		r7,r7,0x7f7fffff@l	li		r9,VIEWPORT_X	li		r10,VIEWPORT_Y	mullw	r9,r9,r10	//r9 = r9*r10	mtctr	r9			//r9 -> CTR		lwz 	r8,4(r3)	//address of the zbuffer -> r8	resetLoop:	//TODO: figure out how to do this? the STW is wrong.	stw		r7,0(r8)	//store r7 in the word at r8.	addi 	r8,r8,4		//add 4 to r0, store in r8		bdnz	resetLoop	//if r9 != 0, branch to resetLoop}