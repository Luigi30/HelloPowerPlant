#include ":3D:3DTypes.h"#include "ShapeHelper.h"Vector3f Matrix44::MatrixVectorProduct(Vector3f v){	Vector3f result;	const float w = 1;		result.x = data[0][0]*v.x + data[0][1]*v.y + data[0][2]*v.z + data[0][3] * w;	result.y = data[1][0]*v.x + data[1][1]*v.y + data[1][2]*v.z + data[1][3] * w;	result.z = data[2][0]*v.x + data[2][1]*v.y + data[2][2]*v.z + data[2][3] * w;		return result;}Matrix44 Orientation::GetTransformationMatrix(){	return 	Matrix44::Identity() * 			GetTranslationMatrix() *			GetXRotationMatrix() * GetYRotationMatrix() * GetZRotationMatrix() *			GetScaleMatrix();}Matrix44 Orientation::GetTranslationMatrix(){	Matrix44 t = Matrix44::Identity();		t.data[0][3] = translation.x;	t.data[1][3] = translation.y;	t.data[2][3] = translation.z;		return t;	}	Matrix44 Orientation::GetScaleMatrix(){	Matrix44 s = Matrix44::Identity();		s.data[0][0] = scale.x;	s.data[1][1] = scale.y;	s.data[2][2] = scale.z;		return s;	}	Matrix44 Orientation::GetXRotationMatrix(){	float xRad = rotation.x * ONE_RADIAN;	Matrix44 mX = Matrix44::Identity();		mX.data[1][1] = std::cos(xRad);	mX.data[1][2] = std::sin(xRad);	mX.data[2][1] = -std::sin(xRad);	mX.data[2][2] = std::cos(xRad);		return mX;		}Matrix44 Orientation::GetYRotationMatrix(){	float yRad = rotation.y * ONE_RADIAN;	Matrix44 mY = Matrix44::Identity();		mY.data[0][0] = std::cos(yRad);	mY.data[0][2] = -std::sin(yRad);	mY.data[2][0] = std::sin(yRad);	mY.data[2][2] = std::cos(yRad);		return mY;		}Matrix44 Orientation::GetZRotationMatrix(){	float zRad = rotation.z * ONE_RADIAN;	Matrix44 mZ = Matrix44::Identity();		mZ.data[0][0] = std::cos(zRad);	mZ.data[0][1] = std::sin(zRad);	mZ.data[1][0] = -std::sin(zRad);	mZ.data[1][1] = std::cos(zRad);		return mZ;	}Matrix44 Orientation::GetPerspectiveMatrix(){	Matrix44 p = Matrix44::Identity();		p.data[2][2] = (CULL_NEAR + CULL_FAR) / CULL_NEAR;	p.data[2][3] = -CULL_FAR;	p.data[3][2] = 1/CULL_NEAR;		return p;}/* Triangle */Vector3f Triangle::CalculateSurfaceNormal(){	Vector3f U, V;		U = vertices[1] - vertices[0];	V = vertices[2] - vertices[0];		return Vector3f::CrossProduct(U, V).Normalize();}Winding Triangle::GetWinding(){	//Sum the edges (x2-x1)*(y2+y1).	//If the result is positive, the triangle's winding is clockwise.	//If the result is negative, the triangle's winding is counter-clockwise.	SInt64 sum = 0;	sum += (vertices[1].x - vertices[0].x)*(vertices[1].y + vertices[0].y);	sum += (vertices[2].x - vertices[1].x)*(vertices[2].y + vertices[1].y);	sum += (vertices[0].x - vertices[2].x)*(vertices[0].y + vertices[2].y);		if(sum < 0) return WINDING_CCW;	else return WINDING_CW;}Vector3f Triangle::Centroid(){	return Vector3f((vertices[0].x + vertices[1].x + vertices[2].x) / 3.0f,					(vertices[0].y + vertices[1].y + vertices[2].y) / 3.0f,					(vertices[0].z + vertices[1].z + vertices[2].z) / 3.0f);}